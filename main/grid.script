local cell_state = require("main.cell_state")
local event_bus = require("main.event_bus_module")
local factory_component = "#cell_factory"
local GAME_STATE = require('main.game_state')

go.property("width", 0)
go.property("height", 0)
go.property("first_state_time", 0)
go.property("second_state_time", 0)

local function check_state(self, cell)
	local state = go.get(cell, "state")
	if state == _G.cell_state.RIGHT then
		self.count_is_right_cells = self.count_is_right_cells + 1
	end

	if state == _G.cell_state.FAIL then
		self.count_is_fail_cells = self.count_is_fail_cells + 1
	end

	if self.count_is_right_cells == self.cells_is_right_count then
		msg.post("/gui", "win_level")
	end
	
	if self.count_is_fail_cells > self.cells_is_fail_count then
		msg.post("/gui", "lose_level")
	end
end

function init(self)
	math.randomseed(os.time())
	self.is_first_state = true
	self.is_second_state = false
	_G.cell_state = cell_state
	self.cells = {}
	self.cells_is_right_count = 0
	self.count_is_right_cells = 0
	self.cells_is_fail_count = 0
	self.count_is_fail_cells = 0

	self.set_is_right_cell = function ()
		local random_number = math.random(2)
		if random_number == 1 then
			self.cells_is_right_count = self.cells_is_right_count + 1
			return true
		end
		return false
	end

	for i = 1, self.width do
		for j = 1, self.height do
			local spawn_pos = go.get_position() - 
				vmath.vector3(((self.width + 1) / 2 * 150) + (i * 150 * -1), 
					((self.height + 1) * 150 / 2 * -1) + (j * 150), 
					0)
			local cell = factory.create(factory_component,
				vmath.vector3(spawn_pos),
				nil,
				{
					state = _G.cell_state.EMPTY,
					is_right_cell = self.set_is_right_cell()
				})
			self.cells_is_fail_count = math.floor(self.cells_is_right_count / 4)
			table.insert(self.cells, cell)
		end
	end
	self.time = 0
	self.time_increase = 1

	self.on_level_pause_handler = function ()
		self.time_increase = 0
	end

	self.on_level_resume_handler = function ()
		self.time_increase = 1
	end

	event_bus.EVENT_BUS:subscribe(GAME_STATE.EVENTS.on_level_pause, self.on_level_pause_handler)
	event_bus.EVENT_BUS:subscribe(GAME_STATE.EVENTS.on_level_resume, self.on_level_resume_handler)
end

function final(self)
	self.time = 0
	event_bus.EVENT_BUS:unsubscribe(GAME_STATE.EVENTS.on_level_pause, self.on_level_pause_handler)
	event_bus.EVENT_BUS:unsubscribe(GAME_STATE.EVENTS.on_level_resume, self.on_level_resume_handler)
	self.on_level_pause_handler = nil
	self.on_level_resume_handler = nil
	self.set_is_right_cell = nil
	self.cells = {}
	self.cells_is_right_count = 0
	self.count_is_right_cells = 0
end

function update(self, dt)
	self.time = self.time + (dt * self.time_increase)
	if self.time >= self.first_state_time and self.is_first_state then
		self.is_first_state = false
		self.is_second_state = true
		for _, cell in ipairs(self.cells) do
			msg.post(cell, "show_is_right_cell")
		end
	end

	if self.time >= self.first_state_time + self.second_state_time and self.is_second_state then
		for _, cell in ipairs(self.cells) do
			msg.post(cell, "hide_is_right_cell")
			msg.post(cell, "give_the_player_control")
		end
		self.is_second_state = false
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("on_click_cell") then
		check_state(self, sender)
	end	
end